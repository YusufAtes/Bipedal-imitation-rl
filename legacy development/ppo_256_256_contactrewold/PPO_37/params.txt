(FORWARD REWARD IS TO HIGH ROBOT MOVES UNREALISTIC, 0.5 IS TO HIGH FOR THIS REWARD I DROPPED IT TO 0.25
IMITATION SCALING COEFFICINET IS 13000 I WILL RAISE IT ON THE NEXT ITERATION)
    
    
    
    
    policy_kwargs = dict(net_arch=dict(pi=[256, 256], vf=[256, 256]))
    print("Starting training")

    model = PPO(
        "MlpPolicy",
        policy_kwargs=policy_kwargs,
        device="cpu",
        env=env,
        tensorboard_log="./"+namelist[i] +"/",
        ent_coef=5e-4,
        learning_rate=1e-4,
        clip_range=0.18)

    if use_past_weights:
        # model = PPO.load(past_weight_path,device="cpu",ent_coef=0.01)
        # model.set_env(env)
        print("Loaded past weights")

    model.learn(total_timesteps=total_timesteps, callback=callbacks)


import os
import numpy as np
from scipy.signal import resample
import torch
from gait_generator_net import SimpleFCNN
import gymnasium as gym
from gymnasium import spaces
from gymnasium.utils import seeding
import pybullet as p
import pybullet_data
import time
from animatebiped import animate_biped
from scipy.interpolate import interp1d

class BipedEnv(gym.Env):
    def __init__(self,render=False, render_mode= None, demo_mode=False):
        self.p = p
        self.init_no = 0
        if render_mode == 'human':
            self.physics_client = self.p.connect(self.p.GUI)
        else:
            self.physics_client = self.p.connect(self.p.DIRECT)
        self.observe_mode = False
        self.scale = 1.
        self.dt = 1e-3
        self.demo_mode = demo_mode
        self.p.setAdditionalSearchPath(pybullet_data.getDataPath())
        self.robot = self.p.loadURDF("assets/biped2d.urdf", [0,0,1.185], self.p.getQuaternionFromEuler([0.,0.,0.]),physicsClientId=self.physics_client)
        self.planeId = self.p.loadURDF("plane.urdf",physicsClientId=self.physics_client)
        self.leg_len = 0.94
        self.render_mode = render_mode
        self.joint_idx = [2,3,4,5,6,7,8]

        self.max_steps = int(3*(1/self.dt))
        self.action_space = spaces.Box(low=-1, high=1, shape=(7,), dtype=np.float32)
        self.observation_space = spaces.Box(low=-50, high=50, shape=(58,), dtype=np.float32)

        self.t = 0
        self.gaitgen_net = SimpleFCNN()
        self.gaitgen_net.load_state_dict(torch.load('newnorm_final_hs512_lr0.0001_bs32_epochs10000.pth',weights_only=True))
        
        self.normalizationconst = np.load(rf"gait reference fft5.00/newnormalization_constants.npy")
        self.joint_no = self.p.getNumJoints(self.robot)
        self.max_torque = np.array([1000,1000,500,250,1000,500,250])
        # self.max_torque = 500
        self.kp = np.array([ 0.1 ,  0.3,  0.2,  0.1,  0.3,  0.2,  0.1])
        self.kd = 0.1*self.kp
        self.state = np.zeros(58)
        self.update_const = 0.75
        self.velocity_norrmcoeff = 10.0
        self.pos_normcoeff = np.pi
        self.torque_normcoeff = 1000

    def reset(self,seed=None,test_speed = None, test_angle = None,demo_max_steps = None):
        
        self.test_speed = test_speed
        self.test_angle = test_angle
        self.max_steps = int(3*(1/self.dt))
        self.t = 0
        self.init_no += 1
        self.p.resetSimulation(physicsClientId=self.physics_client)
        self.reference_speed = 0.3 + np.random.rand()*2.7
        self.ramp_angle = np.random.uniform(-6,6) *np.pi / 180

        if demo_max_steps:
            self.max_steps = demo_max_steps
        if self.test_speed is not None:
            self.reference_speed = self.test_speed

        if self.test_angle is not None:
            self.ramp_angle = self.test_angle

        encoder_vec = np.empty((3))   # init_pos + speed + r_leglength + l_leglength + ramp_angle = 0
        encoder_vec[0] = self.reference_speed/3
        encoder_vec[1] = self.leg_len /1.5
        encoder_vec[2] = self.leg_len /1.5
        encoder_vec = torch.tensor(encoder_vec, dtype=torch.float32)    
        self.reference = self.findgait(encoder_vec)                     #Find the gait
        self.reference = np.clip(self.reference, -np.pi/2, np.pi/2)     #Clip the gait

        plane_orientation = self.p.getQuaternionFromEuler([self.ramp_angle, 0 , 0])
        self.planeId = self.p.loadURDF("plane.urdf",physicsClientId=self.physics_client, baseOrientation=plane_orientation)

        self.reset_info = {'current state':self.state}
        self.past_action_error = np.zeros(7)
        self.current_action = np.zeros(7)
        self.target_action = np.zeros(7)
        self.past_target_action = np.zeros(7)
        self.past2_target_action = np.zeros(7)
        self.past_forward_place = 0
        self.control_freq = 10
        self.external_states = np.zeros(3)
        self.init_state()
        self.return_state()

        return self.state, self.reset_info

    def step(self,torques):
        # Set torques
        self.target_action = torques * self.max_torque
        for i in range(10):
            self.current_action = self.update_const*self.target_action + (1-self.update_const)*self.current_action 
            self.t+=1
            self.p.setJointMotorControlArray(
                bodyIndex=self.robot,
                jointIndices=self.joint_idx,
                controlMode=self.p.TORQUE_CONTROL,
                forces=self.current_action,
                physicsClientId=self.physics_client
            )
            # Step simulation
            self.p.stepSimulation()
            
            # if self.render_mode == 'human':
            #     time.sleep(self.dt)

        self.past_target_action = self.target_action
        self.past2_target_action = self.past_target_action
        self.return_state()
        if self.render_mode == 'human':
            time.sleep(self.dt)
            reward = 0
            done = False
        else:
            reward, done = self.biped_reward(self.state,torques=self.current_action)
        truncated = False

        if self.t > self.max_steps:
            truncated = True

        return self.state, reward, done, truncated, self.state_info

    def biped_reward(self,x,torques):
        self.imitation_weight = 1 / (1 + np.exp(-5 + 5*self.init_no/13000)) #sigmoid function to scale the imitation weight
        self.alive_weight = 0.2
        self.forward_weight = 0.2
        self.contact_weight = 0.1
        done = False
        reward = 0
        contact_points = self.p.getContactPoints(self.robot, self.planeId)

        if not contact_points:
            reward -=1  * self.contact_weight
        if x[9] < -1:
            reward -=1  * self.contact_weight
        if x[12] < -1:
            reward -=1  * self.contact_weight
        else:
            reward +=len(contact_points)  * self.contact_weight
        

        if self.external_states[2] > 1.4 + np.tan(self.ramp_angle) * self.external_states[1]:
            reward -= 20
            done = True
        elif self.external_states[2] > 1.2+ np.tan(self.ramp_angle) * self.external_states[1]:
            reward -= self.alive_weight
        elif self.external_states[2] < 0.8+ np.tan(self.ramp_angle) * self.external_states[1]:
            reward -= 20
            done = True
        elif self.external_states[2] < 1.0+ np.tan(self.ramp_angle) * self.external_states[1]:
            reward -= 1 * self.alive_weight
        else:
            reward += 1 * self.alive_weight

        hip_joint_pos = x[[7,10]] *self.pos_normcoeff
        hip_ref_pos = x[[34,37]] *self.pos_normcoeff
        reward += self.imitation_weight * np.exp(-5*np.linalg.norm(hip_joint_pos - hip_ref_pos))

        knee_joint_pos = x[[8,11]] *self.pos_normcoeff
        knee_ref_pos = x[[35,38]] *self.pos_normcoeff
        reward += self.imitation_weight *np.exp(-5*np.linalg.norm(knee_joint_pos - knee_ref_pos))

        ankle_joint_pos = x[[9,12]] *self.pos_normcoeff
        ankle_ref_pos = x[[36,39]] *self.pos_normcoeff
        reward += self.imitation_weight *np.exp(-5*np.linalg.norm(ankle_joint_pos - ankle_ref_pos))

        hip_joint_vel = x[[28,31]] * self.velocity_norrmcoeff
        hip_ref_vel = x[[52,55]] * self.velocity_norrmcoeff
        reward += self.imitation_weight * 0.3 * np.exp(-0.1*np.linalg.norm(hip_joint_vel - hip_ref_vel))

        knee_joint_vel = x[[29,32]] * self.velocity_norrmcoeff
        knee_ref_vel = x[[53,56]] * self.velocity_norrmcoeff
        reward += self.imitation_weight * 0.3 * np.exp(-0.1*np.linalg.norm(knee_joint_vel - knee_ref_vel))

        ankle_joint_vel = x[[30,33]] * self.velocity_norrmcoeff
        ankle_ref_vel = x[[54,57]] * self.velocity_norrmcoeff
        reward += self.imitation_weight * 0.3 * np.exp(-0.1*np.linalg.norm(ankle_joint_vel - ankle_ref_vel))

        reward -= 3e-3 * np.mean(np.abs(torques))
        reward += 0.5 * (self.external_states[1] - self.past_forward_place)/ (self.dt * 10) 

        return reward, done
    
    def close(self):
        self.physics_client.disconnect()
        print("Environment closed")


    def findgait(self,input_vec):

        freqs = self.gaitgen_net(input_vec)
        predictions = freqs.reshape(-1,6,2,17)
        predictions = predictions.detach().numpy()
        predictions = predictions[0]
        predictions = self.denormalize(predictions)
        pred_time = self.pred_ifft(predictions)

        return pred_time

    def denormalize(self,pred):
        #form is [5,2,17]
        for i in range(17):
            for k in range(2):
                pred[:,k,i] = pred[:,k,i] * self.normalizationconst[i*2+k]
        return pred
    
        
    def pred_ifft(self,predictions):
        #form is [5,2,17]
        real_pred = predictions[:,0,:]
        imag_pred = predictions[:,1,:]
        predictions = real_pred + 1j*imag_pred

        pred_time = np.fft.irfft(predictions, axis=1)
        pred_time = pred_time.transpose(1,0)
        org_rate = 10

        if self.dt < 0.1:
            num_samples = int((pred_time.shape[0]) * (1/self.dt)/(org_rate))  # resample with self.dt
            # Upsample using Fourier method
            pred_time = resample(pred_time, num_samples, axis=0)
            pred_time = np.tile(pred_time, (5,1))    # Create loop for reference movement
        return pred_time

    # def starting_height(self,rhip_pos,rknee_pos,lhip_pos,lknee_pos,r_flat):
    #     upper_len = 0.45
    #     lower_len = 0.45
    #     foot_len = 0.185
    #     if r_flat:
    #         hip_short = upper_len - (upper_len * np.cos(rhip_pos))
    #         knee_short = lower_len - (lower_len * np.cos(rhip_pos + rknee_pos))
    #         init_pos = 1.185 - hip_short - knee_short 
    #     else:
    #         hip_short = upper_len - (upper_len * np.cos(lhip_pos))
    #         knee_short = lower_len - (lower_len * np.cos(lhip_pos + lknee_pos))
    #         init_pos = 1.185 - hip_short - knee_short  
    #     return init_pos

    def starting_height(self,hip_init,knee_init,ankle_init):


        upper_len = 0.45
        lower_len = 0.45
        foot_len = 0.09

        hip_short = upper_len - (upper_len * np.cos(hip_init) )
        knee_short = lower_len - (lower_len * np.cos(knee_init))
        foot_exten = foot_len * np.sin(np.abs(ankle_init))
        init_pos = 1.190 - hip_short - knee_short 

        return init_pos
    

    def init_state(self):
        if self.demo_mode == False:

            start_idx = np.random.randint(0,500)

            # self.max_steps = self.max_steps - start_idx
            self.reference_idx = start_idx

            rhip_pos = self.reference[start_idx,0]
            rknee_pos = self.reference[start_idx,1]
            rankle_pos = self.reference[start_idx,2]
            lhip_pos = self.reference[start_idx,3]
            lknee_pos = self.reference[start_idx,4]
            lankle_pos = self.reference[start_idx,5]
            
            if np.abs(rhip_pos) > np.abs(lhip_pos):
                hip_init = lhip_pos
            else:
                hip_init = rhip_pos

            if np.abs(rknee_pos) > np.abs(lknee_pos):
                knee_init = lknee_pos
            else:
                knee_init = rknee_pos

            if np.abs(rankle_pos) < np.abs(lankle_pos):
                ankle_init = lankle_pos
            else:
                ankle_init = rankle_pos

            init_z = self.starting_height(hip_init,knee_init,ankle_init)
            del self.robot
            self.robot = self.p.loadURDF("assets/biped2d.urdf", [0,0,init_z+0.02], self.p.getQuaternionFromEuler([0.,0.,0.]))
            self.p.setJointMotorControlArray(self.robot,[0,1,2,3,4,5,6,7,8], self.p.VELOCITY_CONTROL, forces=[0,0,0,0,0,0,0,0,0])

            self.p.resetJointState(self.robot, 3, targetValue = rhip_pos) 
            self.p.resetJointState(self.robot, 4, targetValue = rknee_pos)
            self.p.resetJointState(self.robot, 5, targetValue = rankle_pos)
            self.p.resetJointState(self.robot, 6, targetValue = lhip_pos)
            self.p.resetJointState(self.robot, 7, targetValue = lknee_pos)
            self.p.resetJointState(self.robot, 8, targetValue = lankle_pos)
        else:
            start_idx = 0
            self.reference_idx = start_idx

            rhip_pos = 0.1571
            rknee_pos = 0.0
            rankle_pos = -0.1571
            lhip_pos = -0.1571
            lknee_pos = 0.0
            lankle_pos = 0.1571
            

            init_z = self.starting_height(rhip_pos,lhip_pos,rankle_pos)
            del self.robot
            self.robot = self.p.loadURDF("assets/biped2d.urdf", [0,0,init_z], self.p.getQuaternionFromEuler([0.,0.,0.]))
            self.p.setJointMotorControlArray(self.robot,[0,1,2,3,4,5,6,7,8], self.p.VELOCITY_CONTROL, forces=[0,0,0,0,0,0,0,0,0])

            self.p.resetJointState(self.robot, 3, targetValue = rhip_pos) 
            self.p.resetJointState(self.robot, 4, targetValue = rknee_pos)
            self.p.resetJointState(self.robot, 5, targetValue = rankle_pos)
            self.p.resetJointState(self.robot, 6, targetValue = lhip_pos)
            self.p.resetJointState(self.robot, 7, targetValue = lknee_pos)
            self.p.resetJointState(self.robot, 8, targetValue = lankle_pos)

        self.p.setGravity(0,0,-9.81)
        self.p.setTimeStep(self.dt)

        self.t1_torso_pos = self.p.getJointState(self.robot, 2)[0]
        self.t1_rhip_pos = self.p.getJointState(self.robot, 3)[0]
        self.t1_rknee_pos = self.p.getJointState(self.robot, 4)[0]
        self.t1_rankle_pos = self.p.getJointState(self.robot, 5)[0]
        self.t1_lhip_pos = self.p.getJointState(self.robot, 6)[0]
        self.t1_lknee_pos = self.p.getJointState(self.robot, 7)[0]
        self.t1_lankle_pos = self.p.getJointState(self.robot, 8)[0]


    def return_state(self):
        
        link_state = self.p.getLinkState(self.robot, 2,computeLinkVelocity=True)          #link index 2 is for torso
        (pos_x,pos_y,pos_z) = link_state[0]                #3D position of the link
        y_vel = link_state[6][1]                           #y velocity of the link

        self.torso_pos = self.p.getJointState(self.robot, 2)[0]
        self.rhip_pos = self.p.getJointState(self.robot, 3)[0]
        self.rknee_pos = self.p.getJointState(self.robot, 4)[0]
        self.rankle_pos = self.p.getJointState(self.robot, 5)[0]
        self.lhip_pos = self.p.getJointState(self.robot, 6)[0]
        self.lknee_pos = self.p.getJointState(self.robot, 7)[0]
        self.lankle_pos = self.p.getJointState(self.robot, 8)[0]

        self.torso_vel = self.p.getJointState(self.robot, 2)[1]
        self.rhip_vel = self.p.getJointState(self.robot, 3)[1]
        self.rknee_vel = self.p.getJointState(self.robot, 4)[1]
        self.rankle_vel = self.p.getJointState(self.robot, 5)[1]
        self.lhip_vel = self.p.getJointState(self.robot, 6)[1]
        self.lknee_vel = self.p.getJointState(self.robot, 7)[1]
        self.lankle_vel = self.p.getJointState(self.robot, 8)[1]

        ref_rhip_vel = (self.reference[self.reference_idx+self.t,0] - self.reference[self.reference_idx+self.t-1,0])/self.dt
        ref_rknee_vel = (self.reference[self.reference_idx+self.t,1] - self.reference[self.reference_idx+self.t-1,1])/self.dt
        ref_rankle_vel = (self.reference[self.reference_idx+self.t,2] - self.reference[self.reference_idx+self.t-1,2])/self.dt
        ref_lhip_vel = (self.reference[self.reference_idx+self.t,3] - self.reference[self.reference_idx+self.t-1,3])/self.dt
        ref_lknee_vel = (self.reference[self.reference_idx+self.t,4] - self.reference[self.reference_idx+self.t-1,4])/self.dt
        ref_lankle_vel = (self.reference[self.reference_idx+self.t,5] - self.reference[self.reference_idx+self.t-1,5])/self.dt

        self.state[0] = self.reference_speed /3 
        self.state[1] = self.ramp_angle 
        self.state[2] = 0
        self.state[3] = 0
        self.state[4] = 0
        
        self.past_forward_place = self.external_states[1]
        self.external_states = [pos_x,pos_y,pos_z]

        self.state[5] = y_vel   / 3

        self.state[6:13] = np.array([self.torso_pos, self.rhip_pos, self.rknee_pos, self.rankle_pos, self.lhip_pos, self.lknee_pos, self.lankle_pos]) /self.pos_normcoeff

        self.state[13:20] = np.array([self.past_target_action[0]/self.max_torque[0], self.past_target_action[1]/self.max_torque[1], self.past_target_action[2]/self.max_torque[2], 
                             self.past_target_action[3]/self.max_torque[3], self.past_target_action[4]/self.max_torque[4], self.past_target_action[5]/self.max_torque[5], 
                             self.past_target_action[6]/self.max_torque[6]]) /self.torque_normcoeff
        
        self.state[20:27] = np.array([self.t1_torso_pos, self.t1_rhip_pos, self.t1_rknee_pos, self.t1_rankle_pos, self.t1_lhip_pos, 
                             self.t1_lknee_pos, self.t1_lankle_pos]) /self.pos_normcoeff
        # self.state[27:34] = [self.past2_target_action[0]/self.max_torque, self.past2_target_action[1]/self.max_torque, self.past2_target_action[2]/self.max_torque,
        #                      self.past2_target_action[3]/self.max_torque, self.past2_target_action[4]/self.max_torque, self.past2_target_action[5]/self.max_torque,
        #                      self.past2_target_action[6]/self.max_torque]
        self.state[27:34] = np.array([self.torso_vel, self.rhip_vel, self.rknee_vel, self.rankle_vel, self.lhip_vel, 
                             self.lknee_vel, self.lankle_vel]) /self.velocity_norrmcoeff

        self.state[34:40] = np.array([self.reference[self.reference_idx+self.t,0], self.reference[self.reference_idx+self.t,1], 
                             self.reference[self.reference_idx+self.t,2], self.reference[self.reference_idx+self.t,3],
                             self.reference[self.reference_idx+self.t,4], self.reference[self.reference_idx+self.t,5]]) / self.pos_normcoeff
        
        self.state[40:46] = np.array([self.reference[self.reference_idx+self.t+10,0], self.reference[self.reference_idx+self.t+10,1],
                                self.reference[self.reference_idx+self.t+10,2], self.reference[self.reference_idx+self.t+10,3],
                                self.reference[self.reference_idx+self.t+10,4], self.reference[self.reference_idx+self.t+10,5]]) / self.pos_normcoeff
        
        # self.state[53:59] = [self.reference[self.reference_idx+self.t+50,0], self.reference[self.reference_idx+self.t+50,1],
        #                         self.reference[self.reference_idx+self.t+50,2], self.reference[self.reference_idx+self.t+50,3],
        #                         self.reference[self.reference_idx+self.t+50,4], self.reference[self.reference_idx+self.t+50,5]]
        
        self.state[46:52] = np.array([self.reference[self.reference_idx+self.t+100,0], self.reference[self.reference_idx+self.t+100,1],
                                self.reference[self.reference_idx+self.t+100,2], self.reference[self.reference_idx+self.t+100,3],
                                self.reference[self.reference_idx+self.t+100,4], self.reference[self.reference_idx+self.t+100,5]]) / self.pos_normcoeff
        
        self.state[52:58] = np.array([ref_rhip_vel, ref_rknee_vel, ref_rankle_vel,ref_lhip_vel, ref_lknee_vel, ref_lankle_vel]) /self.velocity_norrmcoeff
        
        self.t1_torso_pos = self.torso_pos
        self.t1_rhip_pos = self.rhip_pos
        self.t1_rknee_pos = self.rknee_pos
        self.t1_rankle_pos = self.rankle_pos
        self.t1_lhip_pos = self.lhip_pos
        self.t1_lknee_pos = self.lknee_pos
        self.t1_lankle_pos = self.lankle_pos

        self.state_info = {0:"reference_speed",
                    1:"ramp_angle", 2:"pos_x (external)", 3:"pos_y (external)", 4:"pos_z (external)", 5:"y_vel",

                    6:"torso_pos", 7:"rhip_pos", 8:"rknee_pos", 9:"rankle_pos", 10:"lhip_pos", 11:"lknee_pos", 12:"lankle_pos",
                    #self.past_target_action
                    13:"t1_torso_action", 14:"t1_rhip_action", 15:"t1_rknee_action", 16:"t1_rankle_action", 17:"t1_lhip_action", 18:"t1_lknee_action", 19:"t1_lankle_action",

                    20:"t1torso_pos", 21:"t1rhip_pos", 22:"t1rknee_pos", 23:"t1rankle_pos", 24:"t1lhip_pos", 25:"t1lknee_pos", 26:"t1lankle_pos",
                    #self.past2_target_action
                    #27:"t2_torso_action", 28:"t2_rhip_action", 29:"t2_rknee_action", 30:"t2_rankle_action", 31:"t2_lhip_action", 32:"t2_lknee_action", 33:"t2_lankle_action",

                    27:"torso_vel", 28:"rhip_vel", 29:"rknee_vel", 30:"rankle_vel", 31:"lhip_vel", 32:"lknee_vel", 33:"lankle_vel",
                    
                    34:"t1_ref_rhip", 35:"t1_ref_rknee",36:"t1_ref_rankle" ,37:"t1_ref_lhip", 38:"t1_ref_lknee",39:"t1_ref_lankle",

                    40:"t2_ref_rhip", 41:"t2_ref_rknee",42:"t2_ref_rankle", 43:"t2_ref_lhip", 44:"t2_ref_lknee",45:"t2_ref_lankle",

                    #53:"t50_ref_rhip", 54:"t50_ref_rknee",55:"t50_ref_rankle", 56:"t50_ref_lhip", 57:"t50_ref_lknee",58:"t50_ref_lankle",

                    46:"t100_ref_rhip", 47:"t100_ref_rknee",48:"t100_ref_rankle", 49:"t100_ref_lhip", 50:"t100_ref_lknee",51:"t100_ref_lankle",

                    52:'ref_rhip_vel', 53:'ref_rknee_vel',54:"ref_rankle_vel", 55:'ref_lhip_vel', 56:'ref_lknee_vel',57:"ref_lankle_vel"}

        # return self.state, self.state_info
    

    def return_external_state(self):
        return self.external_states
